package com.shopfloor.backend.database.objects;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Entity representing an order in the database.
 * Contains details about the order, including its number, name, description, creator, timestamps, associated workflows, equipment, products, and executions.
 * @author David Todorov (https://github.com/david-todorov)
 */
@Entity
@Table(name = "orders")
@Setter
@Getter
public class OrderDBO {

    /**
     * Unique identifier for the order.
     * Auto-generated by the database.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Setter(AccessLevel.NONE)
    @Column(name = "id")
    private Long id;

    /**
     * Unique number assigned to the order.
     * Cannot be null and must be unique.
     */
    @Column(name = "order_number", nullable = false, unique = true, length = 255)
    private String orderNumber;

    /**
     * Name of the order.
     * Cannot be null.
     */
    @Column(name = "name", nullable = false, length = 255)
    private String name;

    /**
     * Description of the order.
     * Stored as a text column in the database.
     */
    @Column(name = "description", columnDefinition = "TEXT")
    private String description;

    /**
     * ID of the user who created the order.
     */
    @Column(name = "created_by")
    private Long createdBy;

    /**
     * ID of the user who last updated the order.
     */
    @Column(name = "updated_by")
    private Long updatedBy;

    /**
     * Timestamp when the order was created.
     * Cannot be null and is not updatable.
     */
    @Column(name = "created_at", nullable = false, updatable = false)
    @Temporal(TemporalType.TIMESTAMP)
    private Date createdAt;

    /**
     * Timestamp when the order was last updated.
     */
    @Column(name = "updated_at")
    @Temporal(TemporalType.TIMESTAMP)
    private Date updatedAt;

    /**
     * List of workflows associated with the order.
     * The workflows are ordered by their ordering index in ascending order.
     * Cascade type is set to ALL, meaning all operations (persist, merge, remove, refresh, detach) are cascaded to the workflows.
     * Fetch type is set to LAZY, meaning the workflows are loaded on demand.
     * Orphan removal is enabled, meaning if a workflow is removed from the list, it will be deleted from the database.
     */
    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)
    @JoinColumn(name = "order_id")
    @OrderBy("orderingIndex ASC")
    private List<WorkflowDBO> workflows;

    /**
     * List of equipment associated with the order.
     * Cascade type is set to PERSIST and MERGE, meaning these operations are cascaded to the equipment.
     * Fetch type is set to EAGER, meaning the equipment is loaded immediately.
     * The join table 'order_equipment' is used to manage the many-to-many relationship.
     */
    @ManyToMany(cascade = { CascadeType.PERSIST, CascadeType.MERGE }, fetch = FetchType.EAGER)
    @JoinTable(name = "order_equipment", joinColumns = @JoinColumn(name = "order_id"), inverseJoinColumns = @JoinColumn(name = "equipment_id"))
    private List<EquipmentDBO> equipment;

    /**
     * The product that comes before this order.
     * Fetch type is set to EAGER, meaning the product is loaded immediately.
     */
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "before_product_id")
    private ProductDBO beforeProduct;

    /**
     * The product that comes after this order.
     * Fetch type is set to EAGER, meaning the product is loaded immediately.
     */
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "after_product_id")
    private ProductDBO afterProduct;

    /**
     * The total time required to complete the order, in minutes.
     */
    @Column(name = "total_time_required")
    private Integer totalTimeRequired;

    /**
     * List of executions associated with the order.
     * Cascade type is set to PERSIST and MERGE, meaning these operations are cascaded to the executions.
     * Fetch type is set to LAZY, meaning the executions are loaded on demand.
     */
    @OneToMany(
            cascade = {CascadeType.PERSIST, CascadeType.MERGE, CascadeType.DETACH, CascadeType.REMOVE},
            fetch = FetchType.LAZY,
            mappedBy = "order",
            orphanRemoval = false
    )
    private List<ExecutionDBO> executions;

    /**
     * Constructs an OrderDBO with empty lists for equipment, workflows, and executions.
     */
    public OrderDBO() {
        this.equipment = new ArrayList<EquipmentDBO>();
        this.workflows = new ArrayList<WorkflowDBO>();
        this.executions = new ArrayList<ExecutionDBO>();
    }

    /**
     * Sets the before product and ensures bidirectional consistency.
     * @param newBeforeProduct the new before product to set
     */
    public void setBeforeProduct(ProductDBO newBeforeProduct) {
        this.clearBeforeProduct();
        this.beforeProduct = newBeforeProduct;
        if (newBeforeProduct != null) {
            newBeforeProduct.getOrdersAsBeforeProduct().add(this);
        }
    }

    /**
     * Sets the after product and ensures bidirectional consistency.
     * @param newAfterProduct the new after product to set
     */
    public void setAfterProduct(ProductDBO newAfterProduct) {
        this.clearAfterProduct();
        this.afterProduct = newAfterProduct;
        if (newAfterProduct != null) {
            newAfterProduct.getOrdersAsAfterProduct().add(this);
        }
    }

    /**
     * Clears the before product association.
     */
    public void clearBeforeProduct() {
        if (this.beforeProduct != null) {
            this.beforeProduct.getOrdersAsBeforeProduct().remove(this);
            this.beforeProduct = null;
        }
    }

    /**
     * Clears the after product association.
     */
    public void clearAfterProduct() {
        if (this.afterProduct != null) {
            this.afterProduct.getOrdersAsAfterProduct().remove(this);
            this.afterProduct = null;
        }
    }

    /**
     * Adds equipment to the order and ensures bidirectional consistency.
     * @param equipment the equipment to add
     */
    public void addEquipment(EquipmentDBO equipment) {
        if (!this.equipment.contains(equipment)) {
            this.equipment.add(equipment);
            equipment.getOrders().add(this);
        }
    }

    /**
     * Removes equipment from the order and ensures bidirectional consistency.
     * @param equipment the equipment to remove
     */
    public void removeEquipment(EquipmentDBO equipment) {
        if (this.equipment.contains(equipment)) {
            this.equipment.remove(equipment);
            equipment.getOrders().remove(this);
        }
    }

    /**
     * Clears the equipment list.
     */
    public void clearEquipmentList() {
        for (EquipmentDBO equipment : new ArrayList<>(this.equipment)) {
            removeEquipment(equipment);
        }
    }

    /**
     * Sets the equipment list and ensures bidirectional consistency.
     * @param equipments the list of equipment to set
     */
    public void setEquipmentList(List<EquipmentDBO> equipments) {
        clearEquipmentList();
        for (EquipmentDBO equipment : equipments) {
            addEquipment(equipment);
        }
    }

    /**
     * Adds an execution to the order and ensures bidirectional consistency.
     * @param execution the execution to add
     */
    public void addExecution(ExecutionDBO execution) {
        if (!this.executions.contains(execution)) {
            this.executions.add(execution);
            execution.setOrder(this);
        }
    }

    /**
     * Removes an execution from the order and ensures bidirectional consistency.
     * @param execution the execution to remove
     */
    public void removeExecution(ExecutionDBO execution) {
        if (this.executions.contains(execution)) {
            this.executions.remove(execution);
            execution.setOrder(null);
        }
    }

    /**
     * Clears the executions list.
     */
    public void clearExecutions() {
        for (ExecutionDBO execution : new ArrayList<>(this.executions)) {
            removeExecution(execution);
        }
    }

    /**
     * Sorts the entities within the order. Based on the ordering index of the workflows, tasks, and items.
     */
    public void sortEntities() {
        if (!workflows.isEmpty()) {
            workflows.sort(Comparator.comparingInt(WorkflowDBO::getOrderingIndex));
            for (WorkflowDBO workflow : workflows) {
                if (!workflow.getTasks().isEmpty()) {
                    workflow.getTasks().sort(Comparator.comparingInt(TaskDBO::getOrderingIndex));
                    for (TaskDBO task : workflow.getTasks()) {
                        if (!task.getItems().isEmpty()) {
                            task.getItems().sort(Comparator.comparingInt(ItemDBO::getOrderingIndex));
                        }
                    }
                }
            }
        }
    }

    /**
     * Synchronizes the equipment list with the provided list.
     * Removes equipment that are not in the provided list and adds new equipment.
     * Keeps existing equipment that are in both lists
     * @param equipments the list of equipment to synchronize with
     */
    public void synchronizeEquipmentList(List<EquipmentDBO> equipments) {
        Set<Long> newEquipmentIds = equipments.stream()
                .map(EquipmentDBO::getId)
                .collect(Collectors.toSet());

        for (EquipmentDBO existingEquipment : new ArrayList<>(this.equipment)) {
            if (!newEquipmentIds.contains(existingEquipment.getId())) {
                removeEquipment(existingEquipment);
            }
        }

        for (EquipmentDBO newEquipment : equipments) {
            if (!this.equipment.contains(newEquipment)) {
                addEquipment(newEquipment);
            }
        }
    }
}
